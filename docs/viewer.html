<!DOCTYPE html>
<html>
<head>
    <title>RaQuet Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Client-side RaQuet file viewer powered by DuckDB-WASM and deck.gl">
    <script src="https://unpkg.com/deck.gl@9.0.16/dist.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #container { width: 100vw; height: 100vh; position: relative; }
        #map { width: 100%; height: 100%; background: #e8e8e8; }

        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.95); color: #333;
            padding: 20px; border-radius: 12px;
            max-width: 400px; z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #controls h2 {
            margin: 0 0 5px 0;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #controls h2 img { height: 28px; }
        #controls .subtitle {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 15px;
        }
        #controls label {
            display: block;
            font-size: 0.85em;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }
        #controls input {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
        }
        #controls input:focus {
            outline: none;
            border-color: #4a90d9;
            box-shadow: 0 0 0 3px rgba(74,144,217,0.1);
        }
        #controls button {
            width: 100%;
            padding: 12px 20px;
            cursor: pointer;
            background: #4a90d9;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }
        #controls button:hover { background: #3a7bc8; }
        #controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 15px;
            font-size: 13px;
            color: #666;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        #stats {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.8); color: #4ecca3;
            padding: 10px 15px; border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px; z-index: 100;
        }
        .loading { color: #e6a23c !important; }
        .error { color: #f56c6c !important; }
        .success { color: #67c23a !important; }

        #info-link {
            display: block;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            font-size: 0.85em;
            color: #666;
        }
        #info-link a {
            color: #4a90d9;
            text-decoration: none;
        }
        #info-link a:hover { text-decoration: underline; }

        /* Sample files dropdown */
        .sample-files {
            margin-bottom: 12px;
        }
        .sample-files select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            background: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="map"></div>
        <div id="controls">
            <h2>RaQuet Viewer</h2>
            <p class="subtitle">Client-side viewer powered by DuckDB-WASM</p>

            <div class="sample-files">
                <label>Sample Files</label>
                <select id="sampleSelect" onchange="selectSample()">
                    <option value="">-- Select a sample --</option>
                    <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/naip_test.parquet">NAIP Aerial Imagery (NY)</option>
                    <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/europe_optimized.parquet">Europe</option>
                    <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/riyadh_optimized.parquet">Riyadh</option>
                </select>
            </div>

            <label>Or enter RaQuet file URL</label>
            <input type="text" id="parquetUrl"
                   placeholder="https://example.com/raster.parquet">
            <button id="loadBtn" onclick="loadDataset()">Load Dataset</button>
            <div id="status">Enter a URL or select a sample file to get started.</div>

            <div id="info-link">
                <a href="index.html">&larr; Back to RaQuet documentation</a><br>
                <a href="https://github.com/CartoDB/raquet" target="_blank">GitHub Repository</a><br>
                <span style="margin-top: 10px; display: inline-block; color: #666;">An open source project by <a href="https://carto.com" target="_blank">CARTO</a></span>
            </div>
        </div>
        <div id="stats">Ready</div>
    </div>

    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm';

        let db = null;
        let conn = null;
        let deckgl = null;
        let metadata = null;
        let parquetUrl = null;
        let tilesLoaded = 0;
        let queriesExecuted = 0;
        let dataLoaded = 0; // bytes
        let tileCache = new Map();
        let availableBlocks = new Set(); // Lazily populated

        // Batch loading state
        let pendingRequests = new Map();
        let batchTimeout = null;
        const BATCH_DELAY = 50;
        let bandNames = [];
        let bandType = 'uint8';
        let blockWidth = 256;
        let blockHeight = 256;

        // Convert tile coordinates to QUADBIN (matching Python quadbin library)
        function tileToQuadbin(x, y, z) {
            // Mode 9 (cell/tile mode) header - must match Python quadbin library
            const mode = 9n << 59n;
            // Resolution in bits 52-56
            const resolution = BigInt(z) << 52n;
            // Interleave x and y bits to create index
            let index = 0n;
            for (let i = 0; i < z; i++) {
                index |= ((BigInt(x) >> BigInt(i)) & 1n) << BigInt(2 * i);
                index |= ((BigInt(y) >> BigInt(i)) & 1n) << BigInt(2 * i + 1);
            }
            // Shift index to fill 52 bits, and set lower unused bits to 1 (QUADBIN sentinel)
            const shift = 52 - 2 * z;
            if (shift > 0) {
                index = index << BigInt(shift);
                // Set lower 'shift' bits to 1
                index |= (1n << BigInt(shift)) - 1n;
            }
            return mode | resolution | index;
        }

        const statusEl = document.getElementById('status');
        const statsEl = document.getElementById('stats');
        const loadBtn = document.getElementById('loadBtn');

        function setStatus(msg, type = '') {
            statusEl.textContent = msg;
            statusEl.className = type;
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function updateStats() {
            statsEl.textContent = `Tiles: ${tilesLoaded} | Data: ${formatBytes(dataLoaded)} | Queries: ${queriesExecuted}`;
        }

        window.selectSample = function() {
            const select = document.getElementById('sampleSelect');
            const input = document.getElementById('parquetUrl');
            if (select.value) {
                input.value = select.value;
            }
        };

        function quadbinToTile(cell) {
            const cellBigInt = BigInt(cell);
            const res = Number((cellBigInt >> 52n) & 0x1Fn);
            let x = 0n, y = 0n;
            let index = cellBigInt & ((1n << 52n) - 1n);
            const shift = 52 - 2 * res;
            if (shift > 0) index = index >> BigInt(shift);
            for (let i = 0; i < res; i++) {
                x |= ((index >> BigInt(2 * i)) & 1n) << BigInt(i);
                y |= ((index >> BigInt(2 * i + 1)) & 1n) << BigInt(i);
            }
            return { z: res, x: Number(x), y: Number(y) };
        }

        async function initDuckDB() {
            if (db) return;
            setStatus('Initializing DuckDB-WASM...', 'loading');
            loadBtn.disabled = true;

            const DUCKDB_VERSION = '1.29.0';
            const CDN_BASE = `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${DUCKDB_VERSION}/dist`;
            const logger = new duckdb.ConsoleLogger(duckdb.LogLevel.WARNING);
            const workerScript = `importScripts('${CDN_BASE}/duckdb-browser-eh.worker.js');`;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(workerBlob));

            db = new duckdb.AsyncDuckDB(logger, worker);
            await db.instantiate(`${CDN_BASE}/duckdb-eh.wasm`);
            conn = await db.connect();
            await conn.query(`INSTALL httpfs; LOAD httpfs;`);

            loadBtn.disabled = false;
        }

        async function loadMetadata(url) {
            setStatus('Loading metadata...', 'loading');

            const result = await conn.query(`
                SELECT metadata FROM read_parquet('${url}') WHERE block = 0
            `);
            const rows = result.toArray();
            if (rows.length === 0) throw new Error('No metadata found - is this a RaQuet file?');

            return JSON.parse(rows[0].metadata);
        }

        function decodeTile(bandData, width, height, type) {
            if (!bandData) return null;
            let data;
            try {
                data = pako.inflate(new Uint8Array(bandData));
            } catch (e) {
                data = new Uint8Array(bandData);
            }

            if (type === 'uint16') {
                const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                const pixels = new Uint8Array(width * height);
                for (let i = 0; i < width * height; i++) {
                    pixels[i] = Math.min(255, view.getUint16(i * 2, true) >> 8);
                }
                return pixels;
            }
            return data;
        }

        function createImage(bands, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            const r = bands[0], g = bands[1], b = bands[2];
            for (let i = 0; i < width * height; i++) {
                imageData.data[i * 4] = r ? r[i] : 0;
                imageData.data[i * 4 + 1] = g ? g[i] : 0;
                imageData.data[i * 4 + 2] = b ? b[i] : 0;
                imageData.data[i * 4 + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        async function executeBatch() {
            if (pendingRequests.size === 0) return;

            const requests = new Map(pendingRequests);
            pendingRequests.clear();

            // Calculate QUADBIN IDs for all requested tiles
            const blockIds = [];
            const blockToKey = new Map();
            for (const [key, req] of requests) {
                const [z, x, y] = key.split('/').map(Number);
                const blockId = tileToQuadbin(x, y, z);
                blockIds.push(blockId);
                blockToKey.set(blockId.toString(), key);
                req.blockId = blockId;
            }

            if (blockIds.length === 0) {
                return;
            }

            blockIds.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
            const minBlock = blockIds[0];
            const maxBlock = blockIds[blockIds.length - 1];

            const bandCols = bandNames.slice(0, 3).join(', ');

            try {
                const result = await conn.query(`
                    SELECT block, ${bandCols}
                    FROM read_parquet('${parquetUrl}')
                    WHERE block BETWEEN ${minBlock} AND ${maxBlock}
                `);

                queriesExecuted++;
                const rows = result.toArray();

                const dataMap = new Map();
                for (const row of rows) {
                    // Track data size from band columns
                    for (const name of bandNames.slice(0, 3)) {
                        if (row[name]) {
                            dataLoaded += row[name].length;
                        }
                    }
                    dataMap.set(row.block.toString(), row);
                    availableBlocks.add(row.block.toString());
                }

                for (const [cacheKey, req] of requests) {
                    const row = dataMap.get(req.blockId.toString());
                    if (!row) {
                        tileCache.set(cacheKey, null);
                        req.resolve(null);
                        continue;
                    }

                    const bands = [];
                    for (const name of bandNames.slice(0, 3)) {
                        const bandData = row[name];
                        if (bandData) {
                            bands.push(decodeTile(bandData, blockWidth, blockHeight, bandType));
                        } else {
                            bands.push(null);
                        }
                    }

                    if (!bands[0]) {
                        tileCache.set(cacheKey, null);
                        req.resolve(null);
                        continue;
                    }

                    const canvas = createImage(bands, blockWidth, blockHeight);
                    tilesLoaded++;
                    tileCache.set(cacheKey, canvas);
                    req.resolve(canvas);
                }

                updateStats();

            } catch (e) {
                console.error('Batch query error:', e.message || e);
                console.error('Error details:', e);
                for (const [key, req] of requests) {
                    tileCache.set(key, null);
                    req.resolve(null);
                }
            }
        }

        function getTileData(z, x, y) {
            const cacheKey = `${z}/${x}/${y}`;

            if (tileCache.has(cacheKey)) {
                return Promise.resolve(tileCache.get(cacheKey));
            }

            if (pendingRequests.has(cacheKey)) {
                return pendingRequests.get(cacheKey).promise;
            }

            let resolve, reject;
            const promise = new Promise((res, rej) => {
                resolve = res;
                reject = rej;
            });

            pendingRequests.set(cacheKey, { resolve, reject, promise });

            if (batchTimeout) clearTimeout(batchTimeout);
            batchTimeout = setTimeout(executeBatch, BATCH_DELAY);

            return promise;
        }

        function initMap(meta, url) {
            parquetUrl = url;
            const bounds = meta.bounds;
            const center = meta.center || [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2];
            const zoom = meta.center ? meta.center[2] : meta.minresolution;

            bandNames = meta.bands.map(b => b.name);
            bandType = meta.bands[0]?.type || 'uint8';
            blockWidth = meta.block_width || 256;
            blockHeight = meta.block_height || 256;

            // Fully cleanup previous deck.gl instance
            if (deckgl) {
                deckgl.setProps({ layers: [] });
                deckgl.finalize();
                deckgl = null;
            }

            // CARTO Positron basemap layer
            const basemapLayer = new deck.TileLayer({
                id: 'carto-positron-basemap',
                data: 'https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}@2x.png',
                minZoom: 0,
                maxZoom: 19,
                tileSize: 256,
                renderSubLayers: props => {
                    const {tile, data} = props;
                    const {west, south, east, north} = tile.bbox;
                    return new deck.BitmapLayer({
                        id: `${props.id}-${tile.index.x}-${tile.index.y}-${tile.index.z}`,
                        image: data,
                        bounds: [west, south, east, north],
                    });
                },
            });

            // RaQuet tiles layer
            const raquetLayer = new deck.TileLayer({
                id: 'raquet-tiles',
                minZoom: meta.minresolution,
                maxZoom: meta.maxresolution,
                tileSize: blockWidth,
                extent: bounds,
                getTileData: (tile) => {
                    const {x, y, z} = tile.index;
                    return getTileData(z, x, y);
                },
                renderSubLayers: props => {
                    const {tile, data} = props;
                    if (!data) return null;
                    const {west, south, east, north} = tile.bbox;
                    return new deck.BitmapLayer({
                        id: `${props.id}-${tile.index.x}-${tile.index.y}-${tile.index.z}`,
                        image: data,
                        bounds: [west, south, east, north],
                    });
                },
            });

            deckgl = new deck.DeckGL({
                container: 'map',
                initialViewState: { longitude: center[0], latitude: center[1], zoom: zoom, pitch: 0, bearing: 0 },
                controller: true,
                layers: [basemapLayer, raquetLayer],
            });

            setStatus(`Loaded: ${meta.num_blocks} tiles\nZoom: ${meta.minresolution}-${meta.maxresolution}\nBands: ${bandNames.join(', ')}`, 'success');
        }

        window.loadDataset = async function() {
            const url = document.getElementById('parquetUrl').value.trim();
            if (!url) {
                setStatus('Please enter a URL or select a sample file.', 'error');
                return;
            }

            try {
                loadBtn.disabled = true;
                tilesLoaded = 0;
                queriesExecuted = 0;
                dataLoaded = 0;
                tileCache.clear();
                pendingRequests.clear();
                availableBlocks.clear();
                updateStats();

                await initDuckDB();
                metadata = await loadMetadata(url);
                setStatus(`Loading ${metadata.num_blocks} tiles...`, 'loading');
                initMap(metadata, url);
                loadBtn.disabled = false;
            } catch (e) {
                setStatus(`Error: ${e.message}`, 'error');
                console.error(e);
                loadBtn.disabled = false;
            }
        };

        // Check for URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const fileUrl = urlParams.get('url');
        if (fileUrl) {
            document.getElementById('parquetUrl').value = fileUrl;
            loadDataset();
        }
    </script>
</body>
</html>
