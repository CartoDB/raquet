<!DOCTYPE html>
<html>
<head>
    <title>RaQuet Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Client-side RaQuet file viewer powered by hyparquet and deck.gl">
    <script src="https://unpkg.com/deck.gl@9.0.16/dist.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #map { width: 100%; height: 100%; background: #e8e8e8; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.95); color: #333;
            padding: 20px; border-radius: 12px;
            max-width: 400px; z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #controls h2 {
            margin: 0 0 5px 0;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #controls h2 img { height: 28px; }
        #controls .subtitle { font-size: 0.85em; color: #666; margin-bottom: 15px; }
        #controls label { display: block; font-size: 0.85em; font-weight: 500; margin-bottom: 5px; color: #555; }
        #controls select, #controls input {
            width: 100%; padding: 10px 12px; margin-bottom: 12px;
            border: 1px solid #ddd; border-radius: 6px; font-size: 13px;
        }
        #controls input:focus {
            outline: none;
            border-color: #4a90d9;
            box-shadow: 0 0 0 3px rgba(74,144,217,0.1);
        }
        #controls button {
            width: 100%; padding: 12px 20px; cursor: pointer;
            background: #4a90d9; color: white; border: none;
            border-radius: 6px; font-size: 14px; font-weight: 500;
            transition: background 0.2s;
        }
        #controls button:hover { background: #3a7bc8; }
        #controls button:disabled { background: #ccc; cursor: not-allowed; }
        #status { margin-top: 15px; font-size: 13px; color: #666; white-space: pre-wrap; line-height: 1.5; }
        #stats {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.8); color: #4ecca3;
            padding: 10px 15px; border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px; z-index: 100;
        }
        #debug-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }
        #debug-toggle input {
            width: auto;
            margin: 0;
        }
        #debug-toggle label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        #debug-legend {
            display: none;
            margin-top: 8px;
            font-size: 11px;
            color: #666;
        }
        #debug-legend.visible {
            display: block;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .loading { color: #e6a23c !important; }
        .error { color: #f56c6c !important; }
        .success { color: #67c23a !important; }
        #info-link {
            display: block;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            font-size: 0.85em;
            color: #666;
        }
        #info-link a {
            color: #4a90d9;
            text-decoration: none;
        }
        #info-link a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div id="container">
        <div id="map"></div>
        <div id="controls">
            <h2>RaQuet Viewer</h2>
            <div class="subtitle">Client-side viewer using HTTP range requests</div>

            <label>Sample Files</label>
            <select id="sampleSelect" onchange="selectSample()">
                <option value="">-- Select a sample --</option>
                <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/naip_test_v2.parquet">NAIP Aerial Imagery (NY)</option>
                <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/europe_optimized_v2.parquet">Europe</option>
                <option value="https://storage.googleapis.com/bq_ee_exports/raquet-test/riyadh_optimized_v3.parquet">Riyadh</option>
            </select>

            <label>Or enter RaQuet file URL</label>
            <input type="text" id="parquetUrl" placeholder="https://example.com/raster.parquet">
            <button id="loadBtn" onclick="loadDataset()">Load Dataset</button>

            <div id="status">Enter a URL or select a sample file to get started.</div>
            <div id="debug-toggle">
                <input type="checkbox" id="debugMode" onchange="toggleDebugMode()">
                <label for="debugMode">Debug tile requests</label>
            </div>
            <div id="debug-legend">
                <div class="legend-item"><span class="legend-color" style="background: rgba(255, 100, 100, 0.4); border: 2px solid rgb(255, 100, 100);"></span> Band 1 (red)</div>
                <div class="legend-item"><span class="legend-color" style="background: rgba(100, 255, 100, 0.4); border: 2px solid rgb(100, 255, 100);"></span> Band 2 (green)</div>
                <div class="legend-item"><span class="legend-color" style="background: rgba(100, 100, 255, 0.4); border: 2px solid rgb(100, 100, 255);"></span> Band 3 (blue)</div>
                <div class="legend-item"><span class="legend-color" style="background: rgba(255, 255, 100, 0.4); border: 2px solid rgb(255, 255, 100);"></span> Tile request</div>
            </div>
            <div id="info-link">
                <a href="index.html">&larr; Back to RaQuet documentation</a><br>
                <a href="viewer-how-it-works.html">How the viewer works</a><br>
                <a href="https://github.com/CartoDB/raquet" target="_blank">GitHub Repository</a><br>
                <span style="margin-top: 10px; display: inline-block; color: #666;">An open source project by <a href="https://carto.com" target="_blank">CARTO</a></span>
            </div>
        </div>
        <div id="stats">Ready</div>
    </div>

    <script type="module">
        // Hyparquet imports
        let hyparquet = null;
        let compressors = {};

        async function loadHyparquet() {
            if (!hyparquet) {
                hyparquet = await import('https://cdn.jsdelivr.net/npm/hyparquet/+esm');
                try {
                    const comp = await import('https://cdn.jsdelivr.net/npm/hyparquet-compressors/+esm');
                    compressors = {
                        SNAPPY: comp.decompressSnappy,
                        GZIP: comp.decompressGzip || comp.gunzip,
                        ZSTD: comp.decompressZstd
                    };
                } catch (e) {
                    console.warn('Could not load compressors:', e.message);
                }
            }
            return hyparquet;
        }

        // State
        let parquetUrl = '';
        let parquetFile = null;
        let metadata = null;
        let rowGroupIndex = []; // Array of { minBlock, maxBlock, rowStart, rowEnd }
        let bandNames = [];
        let bandType = 'uint8';
        let blockWidth = 256;
        let blockHeight = 256;
        let minZoom = 0, maxZoom = 20;
        let dataBounds = null; // [minLon, minLat, maxLon, maxLat]
        let deckInstance = null;

        // Stats
        let tilesLoaded = 0;
        let tilesRendered = 0;
        let bytesTransferred = 0;
        let httpRequests = 0;

        // Cache
        let tileCache = new Map();
        let pendingRequests = new Map();
        let batchTimeout = null;
        const BATCH_DELAY = 50;

        // Request cancellation - track current batch generation
        let batchGeneration = 0;
        let activeBatches = new Set();
        let cancelDebounceTimeout = null;

        // Debug mode state
        let debugMode = false;
        let debugRectangles = []; // Array of { bounds, color, type, timestamp }
        const DEBUG_COLORS = {
            tile: [255, 200, 0, 200],        // Yellow/orange for tile request
            band_0: [255, 50, 50, 180],      // Red for band 1
            band_1: [50, 255, 50, 180],      // Green for band 2
            band_2: [50, 50, 255, 180],      // Blue for band 3
        };
        const DEBUG_RECT_LIFETIME = 5000; // Rectangles fade after 5 seconds

        // UI elements
        const statusEl = document.getElementById('status');
        const statsEl = document.getElementById('stats');
        const loadBtn = document.getElementById('loadBtn');

        function setStatus(msg, type = '') {
            statusEl.textContent = msg;
            statusEl.className = type;
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function updateStats() {
            const overhead = tilesRendered > 0 ? (httpRequests / tilesRendered).toFixed(1) : '0';
            statsEl.textContent = `Tiles: ${tilesRendered} | HTTP: ${httpRequests} (${overhead}/tile) | ${formatBytes(bytesTransferred)}`;
        }

        // Convert tile z/x/y to geographic bounds
        function tileToBounds(z, x, y) {
            const n = Math.pow(2, z);
            const west = (x / n) * 360 - 180;
            const east = ((x + 1) / n) * 360 - 180;
            const north = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
            const south = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;
            return { west, south, east, north };
        }

        // Add a debug rectangle for visualization
        function addDebugRect(z, x, y, type, bandIndex = null) {
            if (!debugMode) return;

            const bounds = tileToBounds(z, x, y);
            const now = Date.now();

            // Calculate inset based on type for non-overlapping visualization
            // Outer (largest): tile request (yellow)
            // Middle layers: bands with decreasing size
            let insetFactor;
            if (type === 'tile') {
                insetFactor = 0;
            } else if (bandIndex !== null) {
                // Each band gets progressively smaller: 0.02, 0.04, 0.06 inset
                insetFactor = 0.02 + (bandIndex * 0.02);
            } else {
                insetFactor = 0;
            }

            const width = bounds.east - bounds.west;
            const height = bounds.north - bounds.south;
            const inset = Math.min(width, height) * insetFactor;

            const polygon = [
                [bounds.west + inset, bounds.north - inset],
                [bounds.east - inset, bounds.north - inset],
                [bounds.east - inset, bounds.south + inset],
                [bounds.west + inset, bounds.south + inset],
                [bounds.west + inset, bounds.north - inset]
            ];

            const colorKey = bandIndex !== null ? `band_${bandIndex}` : type;
            const color = DEBUG_COLORS[colorKey] || DEBUG_COLORS.tile;

            debugRectangles.push({
                polygon,
                color,
                type: colorKey,
                timestamp: now,
                z, x, y
            });

            // Clean up old rectangles
            debugRectangles = debugRectangles.filter(r => now - r.timestamp < DEBUG_RECT_LIFETIME);

            // Update the debug layer
            updateDebugLayer();
        }

        // Update the debug layer in deck.gl
        function updateDebugLayer() {
            if (!deckInstance || !debugMode) return;

            const now = Date.now();

            // Calculate opacity based on age (fade out over time)
            const rectanglesWithOpacity = debugRectangles.map(r => {
                const age = now - r.timestamp;
                const opacity = Math.max(0, 1 - (age / DEBUG_RECT_LIFETIME));
                return { ...r, opacity };
            }).filter(r => r.opacity > 0);

            const debugLayer = new globalThis.deck.PolygonLayer({
                id: 'debug-requests',
                data: rectanglesWithOpacity,
                getPolygon: d => d.polygon,
                getFillColor: d => [...d.color.slice(0, 3), Math.floor(d.color[3] * d.opacity * 0.5)],
                getLineColor: d => [...d.color.slice(0, 3), Math.floor(255 * d.opacity)],
                getLineWidth: 3,
                lineWidthUnits: 'pixels',
                filled: true,
                stroked: true,
                pickable: false,
                updateTriggers: {
                    getFillColor: [now],
                    getLineColor: [now]
                }
            });

            // Get current layers and replace/add debug layer
            const currentLayers = deckInstance.props.layers.filter(l => l.id !== 'debug-requests');
            deckInstance.setProps({ layers: [...currentLayers, debugLayer] });
        }

        // Debug layer refresh interval
        let debugRefreshInterval = null;

        // Toggle debug mode
        window.toggleDebugMode = function() {
            debugMode = document.getElementById('debugMode').checked;
            document.getElementById('debug-legend').classList.toggle('visible', debugMode);

            if (debugMode) {
                // Start periodic refresh for fade effect
                if (!debugRefreshInterval) {
                    debugRefreshInterval = setInterval(() => {
                        if (debugMode && debugRectangles.length > 0) {
                            const now = Date.now();
                            debugRectangles = debugRectangles.filter(r => now - r.timestamp < DEBUG_RECT_LIFETIME);
                            updateDebugLayer();
                        }
                    }, 100);
                }
            } else {
                // Stop refresh and clear debug layer
                if (debugRefreshInterval) {
                    clearInterval(debugRefreshInterval);
                    debugRefreshInterval = null;
                }
                debugRectangles = [];
                if (deckInstance) {
                    const currentLayers = deckInstance.props.layers.filter(l => l.id !== 'debug-requests');
                    deckInstance.setProps({ layers: currentLayers });
                }
            }
        };

        // Create a tracked async buffer that counts HTTP requests
        async function createTrackedAsyncBuffer(url) {
            const { asyncBufferFromUrl } = await loadHyparquet();

            // Get the underlying async buffer
            const baseBuffer = await asyncBufferFromUrl({ url });

            // Wrap the slice method to track HTTP requests
            const originalSlice = baseBuffer.slice.bind(baseBuffer);

            baseBuffer.slice = async function(start, end) {
                httpRequests++;
                const requestSize = end - start;
                bytesTransferred += requestSize;
                updateStats();

                const result = await originalSlice(start, end);
                return result;
            };

            return baseBuffer;
        }

        window.selectSample = function() {
            const select = document.getElementById('sampleSelect');
            const input = document.getElementById('parquetUrl');
            if (select.value) input.value = select.value;
        };

        // QUADBIN conversion (matching Python quadbin library)
        function tileToQuadbin(x, y, z) {
            const mode = 9n << 59n;
            const resolution = BigInt(z) << 52n;
            let index = 0n;
            for (let i = 0; i < z; i++) {
                index |= ((BigInt(x) >> BigInt(i)) & 1n) << BigInt(2 * i);
                index |= ((BigInt(y) >> BigInt(i)) & 1n) << BigInt(2 * i + 1);
            }
            const shift = 52 - 2 * z;
            if (shift > 0) {
                index = index << BigInt(shift);
                index |= (1n << BigInt(shift)) - 1n;
            }
            return mode | resolution | index;
        }

        function quadbinToTile(cell) {
            const cellBigInt = BigInt(cell);
            const res = Number((cellBigInt >> 52n) & 0x1Fn);
            let x = 0n, y = 0n;
            let index = cellBigInt & ((1n << 52n) - 1n);
            const shift = 52 - 2 * res;
            if (shift > 0) index = index >> BigInt(shift);
            for (let i = 0; i < res; i++) {
                x |= ((index >> BigInt(2 * i)) & 1n) << BigInt(i);
                y |= ((index >> BigInt(2 * i + 1)) & 1n) << BigInt(i);
            }
            return { z: res, x: Number(x), y: Number(y) };
        }

        // Decode int64 from binary array (little-endian)
        function decodeInt64(bytes) {
            if (!bytes || bytes.length < 8) return null;
            const view = new DataView(bytes.buffer, bytes.byteOffset, 8);
            const low = view.getUint32(0, true);
            const high = view.getInt32(4, true);
            return BigInt(low) + (BigInt(high) << 32n);
        }

        // Build index of row groups with block ID ranges
        function buildRowGroupIndex(metadata) {
            const index = [];
            let rowStart = 0;

            for (let i = 0; i < metadata.row_groups.length; i++) {
                const rg = metadata.row_groups[i];
                const numRows = Number(rg.num_rows);
                const rowEnd = rowStart + numRows;

                const blockCol = rg.columns.find(c =>
                    c.meta_data?.path_in_schema?.includes('block') ||
                    c.meta_data?.path_in_schema?.[0] === 'block'
                );

                let minBlock = null, maxBlock = null;
                if (blockCol?.meta_data?.statistics) {
                    const stats = blockCol.meta_data.statistics;
                    if (stats.min_value instanceof Uint8Array) {
                        minBlock = decodeInt64(stats.min_value);
                        maxBlock = decodeInt64(stats.max_value);
                    } else if (typeof stats.min_value === 'bigint') {
                        minBlock = stats.min_value;
                        maxBlock = stats.max_value;
                    } else {
                        minBlock = BigInt(stats.min_value);
                        maxBlock = BigInt(stats.max_value);
                    }
                }

                index.push({ rowGroupId: i, minBlock, maxBlock, rowStart, rowEnd, numRows });
                rowStart = rowEnd;
            }

            return index;
        }

        // Find row groups that might contain a given block ID
        function findRowGroupsForBlock(blockId) {
            const blockBigInt = BigInt(blockId);
            const matching = [];

            for (const rg of rowGroupIndex) {
                if (rg.minBlock === null || rg.maxBlock === null) {
                    matching.push(rg);
                } else {
                    if (blockBigInt >= rg.minBlock && blockBigInt <= rg.maxBlock) {
                        matching.push(rg);
                    }
                }
            }

            return matching;
        }

        // Decode tile data (handle gzip compression)
        // Returns raw values (not normalized) for proper multi-band normalization
        function decodeTile(bandData, width, height, type) {
            if (!bandData) return null;

            let bytes;
            if (bandData instanceof Uint8Array) {
                bytes = bandData;
            } else if (bandData instanceof ArrayBuffer) {
                bytes = new Uint8Array(bandData);
            } else if (ArrayBuffer.isView(bandData)) {
                bytes = new Uint8Array(bandData.buffer, bandData.byteOffset, bandData.byteLength);
            } else if (Array.isArray(bandData)) {
                bytes = new Uint8Array(bandData);
            } else {
                console.warn('Unknown bandData type:', typeof bandData, bandData?.constructor?.name);
                return null;
            }

            let data;
            try {
                data = pako.inflate(bytes);
            } catch (e) {
                data = bytes;
            }

            if (type === 'uint16') {
                // Return uint16 values as-is for proper normalization later
                const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                const pixels = new Uint16Array(width * height);
                for (let i = 0; i < width * height; i++) {
                    pixels[i] = view.getUint16(i * 2, true);
                }
                return pixels;
            }
            return data;
        }

        // Create image from bands with auto-contrast normalization
        function createImage(bands, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            // Find min/max across all bands for consistent normalization
            let globalMin = Infinity, globalMax = -Infinity;
            for (const band of bands) {
                if (!band) continue;
                for (let i = 0; i < band.length; i++) {
                    if (band[i] < globalMin) globalMin = band[i];
                    if (band[i] > globalMax) globalMax = band[i];
                }
            }

            // Use percentile-based contrast stretch (2nd-98th percentile)
            // to avoid outliers dominating the range
            const allValues = [];
            for (const band of bands) {
                if (!band) continue;
                // Sample values for percentile calculation (for performance)
                const step = Math.max(1, Math.floor(band.length / 10000));
                for (let i = 0; i < band.length; i += step) {
                    allValues.push(band[i]);
                }
            }
            allValues.sort((a, b) => a - b);
            const p2 = allValues[Math.floor(allValues.length * 0.02)] || globalMin;
            const p98 = allValues[Math.floor(allValues.length * 0.98)] || globalMax;

            const minVal = p2;
            const maxVal = p98;
            const range = maxVal - minVal || 1;

            const r = bands[0], g = bands[1], b = bands[2];
            for (let i = 0; i < width * height; i++) {
                // Normalize to 0-255 with contrast stretch
                imageData.data[i * 4] = r ? Math.min(255, Math.max(0, Math.round((r[i] - minVal) / range * 255))) : 0;
                imageData.data[i * 4 + 1] = g ? Math.min(255, Math.max(0, Math.round((g[i] - minVal) / range * 255))) : 0;
                imageData.data[i * 4 + 2] = b ? Math.min(255, Math.max(0, Math.round((b[i] - minVal) / range * 255))) : 0;
                imageData.data[i * 4 + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Fetch tiles for a batch of block IDs
        async function fetchTilesBatch(blockIds) {
            const { parquetRead } = await loadHyparquet();
            const results = new Map();

            // Group block IDs by row group
            const rowGroupRequests = new Map();
            for (const blockId of blockIds) {
                const matchingRGs = findRowGroupsForBlock(blockId);
                for (const rg of matchingRGs) {
                    if (!rowGroupRequests.has(rg.rowGroupId)) {
                        rowGroupRequests.set(rg.rowGroupId, { rg, blockIds: new Set() });
                    }
                    rowGroupRequests.get(rg.rowGroupId).blockIds.add(blockId.toString());
                }
            }

            // Single-phase read: Read block + all bands together, filter client-side
            // This reduces HTTP requests by reading all columns in one pass per row group
            const columnsToRead = ['block', ...bandNames.slice(0, 3)];

            for (const [rgId, { rg, blockIds: rgBlockIds }] of rowGroupRequests) {
                try {
                    let rowGroupData = null;
                    await parquetRead({
                        file: parquetFile,
                        rowStart: rg.rowStart,
                        rowEnd: rg.rowEnd,
                        columns: columnsToRead,
                        compressors,
                        utf8: false,
                        onComplete: (result) => { rowGroupData = result; }
                    });

                    if (!rowGroupData) continue;

                    // Process results - handle both array and object formats
                    const numRows = Array.isArray(rowGroupData)
                        ? rowGroupData.length
                        : (rowGroupData.block?.length || 0);

                    for (let i = 0; i < numRows; i++) {
                        let blockId, bandData;

                        if (Array.isArray(rowGroupData)) {
                            const row = rowGroupData[i];
                            blockId = row[0]?.toString();
                            bandData = row.slice(1);
                        } else {
                            blockId = rowGroupData.block?.[i]?.toString();
                            bandData = bandNames.slice(0, 3).map(name => rowGroupData[name]?.[i]);
                        }

                        if (!rgBlockIds.has(blockId)) continue;

                        const bands = [];
                        for (let j = 0; j < bandData.length; j++) {
                            if (bandData[j]) {
                                const decoded = decodeTile(bandData[j], blockWidth, blockHeight, bandType);
                                bands.push(decoded);
                            }
                        }

                        if (bands.length > 0) {
                            results.set(blockId, { bands });
                        }
                    }
                } catch (e) {
                    if (e.name === 'AbortError') {
                        console.log(`Row group ${rgId} read aborted`);
                        // Don't continue processing if aborted
                        break;
                    }
                    console.error(`Error reading row group ${rgId}:`, e);
                }
            }

            return results;
        }

        // Calculate distance from viewport center for tile prioritization
        // Batch tile loading with cancellation support
        async function executeBatch() {
            if (pendingRequests.size === 0) return;

            // Capture current generation for this batch
            const myGeneration = batchGeneration;
            activeBatches.add(myGeneration);

            const requests = new Map(pendingRequests);
            pendingRequests.clear();

            const blockIds = [];
            for (const [key, req] of requests) {
                const [z, x, y] = key.split('/').map(Number);
                const blockId = tileToQuadbin(x, y, z);
                req.blockId = blockId;
                req.generation = myGeneration;
                req.z = z;
                req.x = x;
                req.y = y;
                blockIds.push(blockId);

                // Debug: show tile request
                addDebugRect(z, x, y, 'tile');
            }

            try {
                const results = await fetchTilesBatch(blockIds);

                // Check if this batch is still relevant
                if (!activeBatches.has(myGeneration)) {
                    for (const req of requests.values()) {
                        req.resolve(null);
                    }
                    return;
                }

                for (const [cacheKey, req] of requests) {
                    // Skip if this specific request's generation is stale
                    if (req.generation !== myGeneration || !activeBatches.has(myGeneration)) {
                        req.resolve(null);
                        continue;
                    }

                    const result = results.get(req.blockId.toString());
                    if (!result) {
                        tileCache.set(cacheKey, null);
                        req.resolve(null);
                        continue;
                    }

                    // Debug: show band reads with slight delay for visual effect
                    if (debugMode && result.bands) {
                        result.bands.forEach((band, idx) => {
                            if (band) {
                                // Stagger the band rectangles slightly in time for visual effect
                                setTimeout(() => {
                                    addDebugRect(req.z, req.x, req.y, 'band', idx);
                                }, idx * 50);
                            }
                        });
                    }

                    const image = createImage(result.bands, blockWidth, blockHeight);
                    tileCache.set(cacheKey, image);
                    tilesLoaded++;
                    tilesRendered++;
                    updateStats();
                    req.resolve(image);
                }
            } catch (e) {
                console.error('Batch fetch error:', e);
                for (const req of requests.values()) {
                    req.resolve(null);
                }
            } finally {
                activeBatches.delete(myGeneration);
            }
        }

        // Cancel all pending requests (called on viewport change)
        function cancelStaleBatches() {
            // Increment generation to invalidate current batches
            batchGeneration++;
            // Mark all active batches as stale
            activeBatches.clear();
            // Clear pending requests that haven't started yet
            for (const req of pendingRequests.values()) {
                req.resolve(null);
            }
            pendingRequests.clear();
            if (batchTimeout) {
                clearTimeout(batchTimeout);
                batchTimeout = null;
            }
        }

        // Get tile data
        function getTileData({ index }) {
            const { x, y, z } = index;
            if (z < minZoom || z > maxZoom) return null;

            const cacheKey = `${z}/${x}/${y}`;
            if (tileCache.has(cacheKey)) return tileCache.get(cacheKey);

            return new Promise((resolve) => {
                pendingRequests.set(cacheKey, { resolve });
                if (batchTimeout) clearTimeout(batchTimeout);
                batchTimeout = setTimeout(executeBatch, BATCH_DELAY);
            });
        }

        // Load dataset
        window.loadDataset = async function() {
            parquetUrl = document.getElementById('parquetUrl').value.trim();
            if (!parquetUrl) {
                setStatus('Please enter a URL', 'error');
                return;
            }

            loadBtn.disabled = true;
            setStatus('Loading hyparquet...', 'loading');

            try {
                const { parquetMetadataAsync } = await loadHyparquet();

                setStatus('Connecting to file...', 'loading');
                parquetFile = await createTrackedAsyncBuffer(parquetUrl);

                setStatus('Reading metadata...', 'loading');
                metadata = await parquetMetadataAsync(parquetFile);

                // Build row group index
                rowGroupIndex = buildRowGroupIndex(metadata);

                // Parse RaQuet metadata from LAST row (block=0 is written last in RaQuet files)
                let raquetMeta = null;
                try {
                    const { parquetRead } = await loadHyparquet();
                    const numRows = Number(metadata.num_rows);
                    let lastRow = null;
                    await parquetRead({
                        file: parquetFile,
                        rowStart: numRows - 1,
                        rowEnd: numRows,
                        columns: ['metadata'],
                        compressors,
                        onComplete: (data) => { lastRow = data; }
                    });

                    // hyparquet returns [[value]] format when reading specific columns
                    let metaStr = null;
                    if (Array.isArray(lastRow) && lastRow[0]) {
                        const metaValue = lastRow[0][0];
                        if (metaValue) {
                            const decoder = new TextDecoder();
                            metaStr = typeof metaValue === 'string' ? metaValue : decoder.decode(new Uint8Array(metaValue));
                        }
                    } else if (lastRow?.metadata && lastRow.metadata[0]) {
                        const decoder = new TextDecoder();
                        const metaBytes = lastRow.metadata[0];
                        metaStr = typeof metaBytes === 'string' ? metaBytes : decoder.decode(new Uint8Array(metaBytes));
                    }

                    if (metaStr) {
                        raquetMeta = JSON.parse(metaStr);
                    }
                } catch (e) {
                    console.warn('Could not read RaQuet metadata:', e);
                }

                if (raquetMeta) {
                    bandNames = raquetMeta.bands?.map(b => b.name) || ['band_1', 'band_2', 'band_3'];
                    bandType = raquetMeta.bands?.[0]?.type || 'uint8';
                    blockWidth = raquetMeta.block_width || 256;
                    blockHeight = raquetMeta.block_height || 256;
                    minZoom = raquetMeta.minresolution || 0;
                    maxZoom = raquetMeta.maxresolution || 20;
                    dataBounds = raquetMeta.bounds || null;
                } else {
                    console.warn('No RaQuet metadata found, using defaults');
                    const schema = metadata.schema || [];
                    bandNames = schema.filter(s => s.name?.startsWith('band_')).map(s => s.name);
                    if (bandNames.length === 0) bandNames = ['band_1', 'band_2', 'band_3'];

                    if (rowGroupIndex.length > 0) {
                        try {
                            const { parquetRead } = await loadHyparquet();
                            let sampleData = null;
                            await parquetRead({
                                file: parquetFile,
                                rowStart: 0,
                                rowEnd: Math.min(100, Number(metadata.num_rows)),
                                columns: ['block'],
                                compressors,
                                onComplete: (data) => { sampleData = data; }
                            });

                            let blocks = [];
                            if (Array.isArray(sampleData)) {
                                blocks = sampleData.map(row => row[0]);
                            } else if (sampleData?.block) {
                                blocks = sampleData.block;
                            }

                            if (blocks.length > 0) {
                                let minLon = 180, maxLon = -180, minLat = 90, maxLat = -90;
                                let sampleZ = 0;
                                for (const block of blocks) {
                                    const tile = quadbinToTile(block);
                                    if (tile.z === 0) continue;
                                    sampleZ = Math.max(sampleZ, tile.z);
                                    const n = Math.pow(2, tile.z);
                                    const lon1 = (tile.x / n) * 360 - 180;
                                    const lon2 = ((tile.x + 1) / n) * 360 - 180;
                                    const lat1Rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * tile.y / n)));
                                    const lat2Rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (tile.y + 1) / n)));
                                    minLon = Math.min(minLon, lon1);
                                    maxLon = Math.max(maxLon, lon2);
                                    minLat = Math.min(minLat, lat2Rad * 180 / Math.PI);
                                    maxLat = Math.max(maxLat, lat1Rad * 180 / Math.PI);
                                }
                                if (minLon < maxLon && minLat < maxLat) {
                                    dataBounds = [minLon, minLat, maxLon, maxLat];
                                    minZoom = Math.max(0, sampleZ - 2);
                                    maxZoom = sampleZ;
                                }
                            }
                        } catch (e) {
                            // Bounds calculation failed, will use fallback
                        }
                    }
                }

                // Reset state
                tileCache.clear();
                tilesLoaded = 0;
                tilesRendered = 0;
                bytesTransferred = 0;
                httpRequests = 0;
                batchGeneration = 0;
                activeBatches.clear();
                pendingRequests.clear();

                // Calculate initial view from dataBounds
                let initialView = { longitude: 0, latitude: 0, zoom: 10 };
                if (dataBounds) {
                    const [minLon, minLat, maxLon, maxLat] = dataBounds;
                    initialView = {
                        longitude: (minLon + maxLon) / 2,
                        latitude: (minLat + maxLat) / 2,
                        zoom: minZoom + 2
                    };
                } else if (rowGroupIndex.length > 0 && rowGroupIndex[0].minBlock) {
                    const firstTile = quadbinToTile(rowGroupIndex[0].minBlock);
                    const n = Math.pow(2, firstTile.z);
                    const lon = (firstTile.x / n) * 360 - 180;
                    const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * firstTile.y / n)));
                    const lat = latRad * 180 / Math.PI;
                    initialView = {
                        longitude: lon,
                        latitude: lat,
                        zoom: Math.min(firstTile.z + 2, maxZoom)
                    };
                }

                setStatus(`Loaded: ${Number(metadata.num_rows).toLocaleString()} tiles\nZoom: ${minZoom}-${maxZoom}\nRow Groups: ${rowGroupIndex.length}\nBands: ${bandNames.join(', ')}`, 'success');

                // Create deck.gl map
                if (deckInstance) deckInstance.finalize();

                deckInstance = new globalThis.deck.DeckGL({
                    container: 'map',
                    initialViewState: { ...initialView, pitch: 0, bearing: 0 },
                    controller: true,
                    onViewStateChange: ({ viewState, interactionState }) => {
                        // Cancel pending requests when user is actively panning/zooming
                        if (interactionState?.isPanning || interactionState?.isZooming) {
                            if (batchTimeout) {
                                clearTimeout(batchTimeout);
                                batchTimeout = null;
                            }
                            if (cancelDebounceTimeout) {
                                clearTimeout(cancelDebounceTimeout);
                            }
                            cancelDebounceTimeout = setTimeout(cancelStaleBatches, 100);
                        }
                        return viewState;
                    },
                    layers: [
                        new globalThis.deck.TileLayer({
                            id: 'basemap',
                            data: 'https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}@2x.png',
                            minZoom: 0,
                            maxZoom: 19,
                            tileSize: 256,
                            renderSubLayers: props => {
                                const {tile, data} = props;
                                const {west, south, east, north} = tile.bbox;
                                return new globalThis.deck.BitmapLayer({
                                    id: `${props.id}-${tile.index.x}-${tile.index.y}-${tile.index.z}`,
                                    image: data,
                                    bounds: [west, south, east, north]
                                });
                            }
                        }),
                        new globalThis.deck.TileLayer({
                            id: 'raquet',
                            getTileData,
                            minZoom,
                            maxZoom,
                            tileSize: blockWidth,
                            extent: dataBounds,
                            // Optimization: Don't load tiles at multiple zoom levels
                            refinementStrategy: 'no-overlap',
                            // Optimization: Limit concurrent tile requests
                            maxRequests: 6,
                            // Optimization: Limit cache size
                            maxCacheSize: 100,
                            renderSubLayers: props => {
                                const {tile, data} = props;
                                if (!data) return null;
                                const {west, south, east, north} = tile.bbox;
                                return new globalThis.deck.BitmapLayer({
                                    id: `${props.id}-${tile.index.x}-${tile.index.y}-${tile.index.z}`,
                                    image: data,
                                    bounds: [west, south, east, north]
                                });
                            }
                        })
                    ]
                });

                updateStats();
                loadBtn.disabled = false;

                // Expose deck instance for debugging
                window.deckInstance = deckInstance;

            } catch (e) {
                setStatus(`Error: ${e.message}`, 'error');
                console.error(e);
                loadBtn.disabled = false;
            }
        };

        // Check for URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const fileUrl = urlParams.get('url');
        if (fileUrl) {
            document.getElementById('parquetUrl').value = fileUrl;
            loadDataset();
        }

        // Initialize
        updateStats();
    </script>
</body>
</html>
